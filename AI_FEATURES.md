# YYCÂ³ AI æ™ºèƒ½åŠŸèƒ½è¯¦ç»†è®¾è®¡

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†æè¿° YYCÂ³ SaaS å¹³å°çš„ AI æ™ºèƒ½åŠŸèƒ½è®¾è®¡æ–¹æ¡ˆï¼ŒåŒ…æ‹¬æŠ€æœ¯æ¶æ„ã€å®ç°ç»†èŠ‚å’Œç”¨æˆ·ä½“éªŒè®¾è®¡ã€‚

## æŠ€æœ¯æ¶æ„

### AI æœåŠ¡å±‚æ¶æ„

\`\`\`
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰ç«¯åº”ç”¨å±‚                              â”‚
â”‚  (Next.js + React + Vercel AI SDK)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   API ç½‘å…³å±‚                              â”‚
â”‚  (Next.js API Routes + Vercel AI Gateway)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   AI æœåŠ¡å±‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ OpenAI   â”‚  â”‚ Anthropicâ”‚  â”‚ è‡ªå®šä¹‰   â”‚              â”‚
â”‚  â”‚ GPT-4    â”‚  â”‚ Claude   â”‚  â”‚ æ¨¡å‹     â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ•°æ®å±‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ å‘é‡æ•°æ®åº“â”‚  â”‚ å…³ç³»æ•°æ®åº“â”‚  â”‚ ç¼“å­˜å±‚   â”‚              â”‚
â”‚  â”‚ Supabase â”‚  â”‚ Postgres â”‚  â”‚ Redis    â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
\`\`\`

## æ ¸å¿ƒ AI åŠŸèƒ½

### 1. æ™ºèƒ½æ•°æ®åˆ†æåŠ©æ‰‹

#### åŠŸèƒ½æè¿°
ç”¨æˆ·å¯ä»¥é€šè¿‡è‡ªç„¶è¯­è¨€ä¸æ•°æ®è¿›è¡Œå¯¹è¯ï¼ŒAI è‡ªåŠ¨ç†è§£æ„å›¾å¹¶ç”Ÿæˆç›¸åº”çš„æ•°æ®æŸ¥è¯¢ã€å¯è§†åŒ–å’Œæ´å¯Ÿã€‚

#### æŠ€æœ¯å®ç°

**å‰ç«¯ç»„ä»¶**:
\`\`\`typescript
// components/ai-analytics-chat.tsx
'use client'

import { useChat } from '@ai-sdk/react'
import { useState } from 'react'

export function AIAnalyticsChat() {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: '/api/ai/analytics',
  })

  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 overflow-y-auto">
        {messages.map(message => (
          <div key={message.id}>
            {message.role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–'} {message.content}
          </div>
        ))}
      </div>
      <form onSubmit={handleSubmit}>
        <input
          value={input}
          onChange={handleInputChange}
          placeholder="è¯¢é—®æ‚¨çš„æ•°æ®..."
        />
      </form>
    </div>
  )
}
\`\`\`

**åç«¯ API**:
\`\`\`typescript
// app/api/ai/analytics/route.ts
import { streamText } from 'ai'
import { openai } from '@ai-sdk/openai'

export async function POST(req: Request) {
  const { messages } = await req.json()

  const result = await streamText({
    model: openai('gpt-4'),
    messages,
    tools: {
      queryDatabase: {
        description: 'æŸ¥è¯¢æ•°æ®åº“è·å–ä¸šåŠ¡æ•°æ®',
        parameters: z.object({
          query: z.string(),
          timeRange: z.string(),
        }),
        execute: async ({ query, timeRange }) => {
          // æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢
          return await executeQuery(query, timeRange)
        },
      },
      generateChart: {
        description: 'ç”Ÿæˆæ•°æ®å¯è§†åŒ–å›¾è¡¨',
        parameters: z.object({
          data: z.array(z.any()),
          chartType: z.enum(['line', 'bar', 'pie']),
        }),
        execute: async ({ data, chartType }) => {
          // ç”Ÿæˆå›¾è¡¨é…ç½®
          return generateChartConfig(data, chartType)
        },
      },
    },
  })

  return result.toUIMessageStreamResponse()
}
\`\`\`

#### ç”¨æˆ·ä½“éªŒæµç¨‹

1. ç”¨æˆ·è¾“å…¥: "æ˜¾ç¤ºæœ¬æœˆé”€å”®é¢è¶‹åŠ¿"
2. AI ç†è§£æ„å›¾å¹¶è°ƒç”¨ `queryDatabase` å·¥å…·
3. è·å–æ•°æ®åè°ƒç”¨ `generateChart` å·¥å…·
4. è¿”å›å¯è§†åŒ–å›¾è¡¨å’Œæ–‡å­—è¯´æ˜
5. ç”¨æˆ·å¯ä»¥ç»§ç»­è¿½é—®: "ä¸ä¸Šæœˆç›¸æ¯”å¦‚ä½•ï¼Ÿ"

### 2. AI åä½œåŠ©æ‰‹

#### ä¼šè®®çºªè¦è‡ªåŠ¨ç”Ÿæˆ

**æŠ€æœ¯å®ç°**:
\`\`\`typescript
// app/api/ai/meeting-notes/route.ts
import { generateText } from 'ai'
import { openai } from '@ai-sdk/openai'

export async function POST(req: Request) {
  const { audioUrl, participants } = await req.json()

  // 1. è¯­éŸ³è½¬æ–‡å­—
  const transcription = await openai.audio.transcriptions.create({
    file: await fetch(audioUrl),
    model: 'whisper-1',
  })

  // 2. ç”Ÿæˆç»“æ„åŒ–çºªè¦
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: \`
      æ ¹æ®ä»¥ä¸‹ä¼šè®®å½•éŸ³è½¬å†™å†…å®¹ï¼Œç”Ÿæˆç»“æ„åŒ–çš„ä¼šè®®çºªè¦ï¼š
      
      å‚ä¼šäººå‘˜: \${participants.join(', ')}
      ä¼šè®®å†…å®¹: \${transcription.text}
      
      è¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¾“å‡ºï¼š
      1. ä¼šè®®ä¸»é¢˜
      2. å…³é”®è®¨è®ºç‚¹
      3. å†³ç­–äº‹é¡¹
      4. å¾…åŠä»»åŠ¡ï¼ˆåŒ…å«è´Ÿè´£äººå’Œæˆªæ­¢æ—¥æœŸï¼‰
      5. ä¸‹æ¬¡ä¼šè®®å®‰æ’
    \`,
  })

  return Response.json({ notes: text })
}
\`\`\`

#### æ™ºèƒ½ä»»åŠ¡åˆ†é…

**ç®—æ³•è®¾è®¡**:
\`\`\`typescript
// lib/ai/task-assignment.ts
interface TeamMember {
  id: string
  name: string
  skills: string[]
  currentWorkload: number
  availability: number
}

interface Task {
  id: string
  title: string
  requiredSkills: string[]
  priority: number
  estimatedHours: number
}

export async function intelligentTaskAssignment(
  task: Task,
  team: TeamMember[]
): Promise<TeamMember> {
  // ä½¿ç”¨ AI æ¨¡å‹è¯„ä¼°æœ€ä½³åˆ†é…
  const { object } = await generateObject({
    model: openai('gpt-4'),
    schema: z.object({
      assignedTo: z.string(),
      reasoning: z.string(),
      confidence: z.number(),
    }),
    prompt: \`
      ä»»åŠ¡: \${task.title}
      æ‰€éœ€æŠ€èƒ½: \${task.requiredSkills.join(', ')}
      ä¼˜å…ˆçº§: \${task.priority}
      é¢„è®¡å·¥æ—¶: \${task.estimatedHours}
      
      å›¢é˜Ÿæˆå‘˜:
      \${team.map(m => \`
        - \${m.name}: æŠ€èƒ½[\${m.skills.join(', ')}], 
          å½“å‰å·¥ä½œé‡: \${m.currentWorkload}%, 
          å¯ç”¨æ€§: \${m.availability}%
      \`).join('\\n')}
      
      è¯·åˆ†æå¹¶æ¨èæœ€åˆé€‚çš„å›¢é˜Ÿæˆå‘˜æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚
    \`,
  })

  return team.find(m => m.id === object.assignedTo)!
}
\`\`\`

### 3. æ™ºèƒ½å®¢æˆ·æœåŠ¡

#### AI å®¢æœæœºå™¨äºº

**å®ç°æ–¹æ¡ˆ**:
\`\`\`typescript
// app/api/ai/customer-support/route.ts
import { streamText } from 'ai'
import { openai } from '@ai-sdk/openai'
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_KEY!
)

export async function POST(req: Request) {
  const { messages, userId } = await req.json()

  // è·å–ç”¨æˆ·ä¸Šä¸‹æ–‡
  const { data: userContext } = await supabase
    .from('users')
    .select('*, subscriptions(*), tickets(*)')
    .eq('id', userId)
    .single()

  // æ£€ç´¢ç›¸å…³çŸ¥è¯†åº“æ–‡æ¡£
  const { data: relevantDocs } = await supabase.rpc('match_documents', {
    query_embedding: await getEmbedding(messages[messages.length - 1].content),
    match_threshold: 0.78,
    match_count: 5,
  })

  const result = await streamText({
    model: openai('gpt-4'),
    system: \`
      ä½ æ˜¯ YYCÂ³ çš„ AI å®¢æœåŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯å¸®åŠ©ç”¨æˆ·è§£å†³é—®é¢˜ã€‚
      
      ç”¨æˆ·ä¿¡æ¯:
      - è®¢é˜…æ–¹æ¡ˆ: \${userContext.subscriptions.plan}
      - è´¦æˆ·çŠ¶æ€: \${userContext.status}
      - å†å²å·¥å•: \${userContext.tickets.length} ä¸ª
      
      ç›¸å…³çŸ¥è¯†åº“:
      \${relevantDocs.map(doc => doc.content).join('\\n\\n')}
      
      è¯·ç”¨å‹å¥½ã€ä¸“ä¸šçš„è¯­æ°”å›ç­”ç”¨æˆ·é—®é¢˜ã€‚å¦‚æœæ— æ³•è§£å†³ï¼Œå»ºè®®ç”¨æˆ·è”ç³»äººå·¥å®¢æœã€‚
    \`,
    messages,
    tools: {
      createTicket: {
        description: 'ä¸ºç”¨æˆ·åˆ›å»ºæ”¯æŒå·¥å•',
        parameters: z.object({
          title: z.string(),
          description: z.string(),
          priority: z.enum(['low', 'medium', 'high']),
        }),
        execute: async (params) => {
          const { data } = await supabase
            .from('tickets')
            .insert({ ...params, user_id: userId })
            .select()
            .single()
          return data
        },
      },
    },
  })

  return result.toUIMessageStreamResponse()
}
\`\`\`

### 4. æ™ºèƒ½å·¥ä½œæµè‡ªåŠ¨åŒ–

#### æµç¨‹ä¼˜åŒ–å»ºè®®

**å®ç°æ–¹æ¡ˆ**:
\`\`\`typescript
// lib/ai/workflow-optimizer.ts
export async function analyzeWorkflow(workflowId: string) {
  // è·å–å·¥ä½œæµæ‰§è¡Œå†å²
  const history = await getWorkflowHistory(workflowId)

  // ä½¿ç”¨ AI åˆ†æç“¶é¢ˆå’Œä¼˜åŒ–æœºä¼š
  const { object } = await generateObject({
    model: openai('gpt-4'),
    schema: z.object({
      bottlenecks: z.array(z.object({
        step: z.string(),
        issue: z.string(),
        impact: z.string(),
      })),
      optimizations: z.array(z.object({
        suggestion: z.string(),
        expectedImprovement: z.string(),
        implementation: z.string(),
      })),
      automationOpportunities: z.array(z.object({
        task: z.string(),
        automationMethod: z.string(),
        timeSaved: z.string(),
      })),
    }),
    prompt: \`
      åˆ†æä»¥ä¸‹å·¥ä½œæµçš„æ‰§è¡Œå†å²ï¼Œè¯†åˆ«ç“¶é¢ˆå¹¶æä¾›ä¼˜åŒ–å»ºè®®ï¼š
      
      \${JSON.stringify(history, null, 2)}
      
      è¯·æä¾›ï¼š
      1. è¯†åˆ«çš„ç“¶é¢ˆ
      2. ä¼˜åŒ–å»ºè®®
      3. è‡ªåŠ¨åŒ–æœºä¼š
    \`,
  })

  return object
}
\`\`\`

## æ•°æ®éšç§ä¸å®‰å…¨

### æ•°æ®å¤„ç†åŸåˆ™
1. **æœ€å°åŒ–åŸåˆ™**: åªå¤„ç†å¿…è¦çš„æ•°æ®
2. **åŠ å¯†ä¼ è¾“**: æ‰€æœ‰ AI è¯·æ±‚ä½¿ç”¨ HTTPS
3. **æ•°æ®è„±æ•**: æ•æ„Ÿä¿¡æ¯åœ¨å‘é€ç»™ AI å‰è¿›è¡Œè„±æ•
4. **ç”¨æˆ·æ§åˆ¶**: ç”¨æˆ·å¯ä»¥é€‰æ‹©é€€å‡º AI åŠŸèƒ½

### å®ç°ç¤ºä¾‹
\`\`\`typescript
// lib/ai/data-privacy.ts
export function sanitizeData(data: any): any {
  // ç§»é™¤æ•æ„Ÿå­—æ®µ
  const sensitiveFields = ['password', 'ssn', 'creditCard']
  
  return Object.keys(data).reduce((acc, key) => {
    if (sensitiveFields.includes(key)) {
      return acc
    }
    
    if (typeof data[key] === 'string') {
      // è„±æ•é‚®ç®±
      if (data[key].includes('@')) {
        const [name, domain] = data[key].split('@')
        acc[key] = \`\${name.slice(0, 2)}***@\${domain}\`
        return acc
      }
      
      // è„±æ•æ‰‹æœºå·
      if (/^\\d{11}$/.test(data[key])) {
        acc[key] = data[key].replace(/(\d{3})\d{4}(\d{4})/, '$1****$2')
        return acc
      }
    }
    
    acc[key] = data[key]
    return acc
  }, {} as any)
}
\`\`\`

## æ€§èƒ½ä¼˜åŒ–

### ç¼“å­˜ç­–ç•¥
\`\`\`typescript
// lib/ai/cache.ts
import { Redis } from '@upstash/redis'

const redis = new Redis({
  url: process.env.KV_REST_API_URL!,
  token: process.env.KV_REST_API_TOKEN!,
})

export async function getCachedResponse(
  key: string,
  generator: () => Promise<string>
): Promise<string> {
  // æ£€æŸ¥ç¼“å­˜
  const cached = await redis.get(key)
  if (cached) {
    return cached as string
  }

  // ç”Ÿæˆæ–°å“åº”
  const response = await generator()

  // ç¼“å­˜ 1 å°æ—¶
  await redis.setex(key, 3600, response)

  return response
}
\`\`\`

### æµå¼å“åº”
æ‰€æœ‰ AI åŠŸèƒ½éƒ½ä½¿ç”¨æµå¼å“åº”ï¼Œæä¾›æ›´å¥½çš„ç”¨æˆ·ä½“éªŒï¼š
- å‡å°‘é¦–å­—èŠ‚æ—¶é—´
- å®æ—¶æ˜¾ç¤ºç”Ÿæˆå†…å®¹
- æ›´å¥½çš„æ„ŸçŸ¥æ€§èƒ½

## ç›‘æ§ä¸åˆ†æ

### AI ä½¿ç”¨åˆ†æ
\`\`\`typescript
// lib/ai/analytics.ts
export async function trackAIUsage(params: {
  feature: string
  userId: string
  tokensUsed: number
  latency: number
  success: boolean
}) {
  await supabase.from('ai_usage_logs').insert({
    ...params,
    timestamp: new Date().toISOString(),
  })
}
\`\`\`

### æˆæœ¬æ§åˆ¶
\`\`\`typescript
// lib/ai/cost-control.ts
export async function checkUsageLimit(userId: string): Promise<boolean> {
  const { data: usage } = await supabase
    .from('ai_usage_logs')
    .select('tokens_used')
    .eq('user_id', userId)
    .gte('timestamp', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))

  const totalTokens = usage?.reduce((sum, log) => sum + log.tokens_used, 0) || 0

  // æ ¹æ®è®¢é˜…æ–¹æ¡ˆè®¾ç½®é™åˆ¶
  const limits = {
    starter: 100000,
    professional: 1000000,
    enterprise: Infinity,
  }

  const userPlan = await getUserPlan(userId)
  return totalTokens < limits[userPlan]
}
\`\`\`

## æœªæ¥å±•æœ›

### å¤šæ¨¡æ€ AI
- å›¾åƒè¯†åˆ«ä¸ç”Ÿæˆ
- è¯­éŸ³äº¤äº’
- è§†é¢‘åˆ†æ

### è¾¹ç¼˜ AI
- åœ¨æµè§ˆå™¨ä¸­è¿è¡Œå°å‹æ¨¡å‹
- å‡å°‘å»¶è¿Ÿ
- æé«˜éšç§æ€§

### ä¸ªæ€§åŒ–æ¨¡å‹
- ä¸ºæ¯ä¸ªä¼ä¸šè®­ç»ƒå®šåˆ¶æ¨¡å‹
- å­¦ä¹ ä¼ä¸šç‰¹å®šæœ¯è¯­å’Œæµç¨‹
- æä¾›æ›´ç²¾å‡†çš„å»ºè®®

---

**æ›´æ–°æ—¶é—´**: 2024-12-25
